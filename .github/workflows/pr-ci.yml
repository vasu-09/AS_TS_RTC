name: Pull Request CI

on:
  pull_request:
    branches: ["main"]
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:

permissions:
  contents: read
  id-token: write
  packages: write

env:
  SERVICES: |
    api-gateway
    authentication-srvice
    Notification-Service
    Real-Time-Communication
    To-Do-List-ecosystem
  AR_HOST: asia-south1-docker.pkg.dev
  AR_REPO: moc-repo
  K8S_NAMESPACE: default
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: ${{ secrets.GKE_CLUSTER }}
  GKE_LOCATION: ${{ secrets.GKE_LOCATION }}

jobs:
  ci:
    name: Quality, Build & Deploy Gate
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Java 17 with Maven cache
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"
          cache: maven

      - name: Run unit tests
        env:
          SERVICES: ${{ env.SERVICES }}
        run: |
          set -euo pipefail
          while IFS= read -r SERVICE; do
            [[ -z "$SERVICE" ]] && continue
            echo "\n>>> Running unit tests for $SERVICE"
            mvn -B -f "$SERVICE/pom.xml" test
          done <<< "$SERVICES"

      - name: Static analysis (SpotBugs)
        env:
          SERVICES: ${{ env.SERVICES }}
        run: |
          set -euo pipefail
          while IFS= read -r SERVICE; do
            [[ -z "$SERVICE" ]] && continue
            echo "\n>>> Running static code analysis for $SERVICE"
            mvn -B -f "$SERVICE/pom.xml" -DskipTests com.github.spotbugs:spotbugs-maven-plugin:4.8.3.2:check
          done <<< "$SERVICES"

      - name: Package services
        env:
          SERVICES: ${{ env.SERVICES }}
        run: |
          set -euo pipefail
          while IFS= read -r SERVICE; do
            [[ -z "$SERVICE" ]] && continue
            echo "\n>>> Packaging artifact for $SERVICE"
            mvn -B -f "$SERVICE/pom.xml" -DskipTests package
          done <<< "$SERVICES"

      - name: Discover Docker build targets
        id: docker-targets
        env:
          SERVICES: ${{ env.SERVICES }}
        run: |
          set -euo pipefail
          TARGETS=""
          while IFS= read -r SERVICE; do
            [[ -z "$SERVICE" ]] && continue
            DOCKERFILE="$SERVICE/Dockerfile"
            if [[ ! -f "$DOCKERFILE" ]]; then
              echo "Skipping $SERVICE, Dockerfile not found at $DOCKERFILE" >&2
              continue
            fi
            NAME_RAW="$(basename "$SERVICE")"
            NAME="$(echo "$NAME_RAW" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9._-]/-/g')"
            TARGETS+="$SERVICE|$NAME|$DOCKERFILE"$'\n'
          done <<< "$SERVICES"

          if [[ -z "$TARGETS" ]]; then
            echo "No Docker targets discovered" >&2
            exit 1
          fi

          printf 'targets<<EOF\n%sEOF\n' "$TARGETS" >> "$GITHUB_OUTPUT"

      - name: Compute build metadata
        id: meta
        env:
          EVENT_NAME: ${{ github.event_name }}
          PR_NUMBER: ${{ github.event.number }}
        run: |
          set -euo pipefail
          SHORT_SHA="${GITHUB_SHA::7}"
          if [[ "$EVENT_NAME" == "pull_request" && -n "$PR_NUMBER" ]]; then
            TAG="pr-${PR_NUMBER}-${SHORT_SHA}"
          else
            TAG="$SHORT_SHA"
          fi

          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build container images
        id: build-images
        env:
          TARGETS: ${{ steps.docker-targets.outputs.targets }}
          TAG: ${{ steps.meta.outputs.tag }}
          AR_HOST: ${{ env.AR_HOST }}
          AR_REPO: ${{ env.AR_REPO }}
          GCP_PROJECT_ID: ${{ env.GCP_PROJECT_ID }}
        run: |
          set -euo pipefail
          if [[ -z "$TARGETS" ]]; then
            echo "No Docker targets were discovered." >&2
            exit 1
          fi

          REGISTRY_PREFIX="$AR_HOST"
          if [[ -n "$GCP_PROJECT_ID" ]]; then
            REGISTRY_PREFIX+="/$GCP_PROJECT_ID/$AR_REPO"
          else
            REGISTRY_PREFIX="local/$AR_REPO"
          fi

          IMAGES=""
          while IFS='|' read -r MODULE NAME DOCKERFILE; do
            [[ -z "$MODULE" ]] && continue
            IMAGE="$REGISTRY_PREFIX/$NAME:$TAG"
            echo "\n>>> Building $MODULE -> $IMAGE"
            if grep -qE '^ARG[[:space:]]+MODULE=' "$DOCKERFILE"; then
              docker build --build-arg MODULE="$MODULE" -t "$IMAGE" -f "$DOCKERFILE" .
            else
              docker build -t "$IMAGE" "$MODULE"
            fi
            IMAGES+="$IMAGE"$'\n'
          done <<< "$TARGETS"

          printf 'images<<EOF\n%sEOF\n' "$IMAGES" >> "$GITHUB_OUTPUT"

      - name: Install Trivy vulnerability scanner
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install -y trivy

      - name: Scan container images for vulnerabilities
        env:
          IMAGES: ${{ steps.build-images.outputs.images }}
        run: |
          set -euo pipefail
          if [[ -z "$IMAGES" ]]; then
            echo "No images built to scan." >&2
            exit 1
          fi

          while IFS= read -r IMAGE; do
            [[ -z "$IMAGE" ]] && continue
            echo "\n>>> Scanning $IMAGE"
            trivy image --scanners vuln --exit-code 1 --severity HIGH,CRITICAL --ignore-unfixed "$IMAGE"
          done <<< "$IMAGES"

      - name: Determine registry & deployment availability
        id: registry-gate
        env:
          EVENT_NAME: ${{ github.event_name }}
          PR_REPO: ${{ github.event.pull_request.head.repo.full_name }}
          BASE_REPO: ${{ github.repository }}
          GCP_PROJECT_ID: ${{ env.GCP_PROJECT_ID }}
        run: |
          set -euo pipefail
          ALLOWED="true"
          if [[ "$EVENT_NAME" == "pull_request" && -n "$PR_REPO" && "$PR_REPO" != "$BASE_REPO" ]]; then
            echo "Registry actions disabled for forked pull requests" >> "$GITHUB_STEP_SUMMARY"
            ALLOWED="false"
          fi

          if [[ -z "$GCP_PROJECT_ID" ]]; then
            echo "Registry actions disabled because GCP_PROJECT_ID secret is not configured" >> "$GITHUB_STEP_SUMMARY"
            ALLOWED="false"
          fi

          echo "allowed=$ALLOWED" >> "$GITHUB_OUTPUT"

      - name: Authenticate to Google Cloud (OIDC)
        if: steps.registry-gate.outputs.allowed == 'true'
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_SA_EMAIL }}

      - name: Configure gcloud
        if: steps.registry-gate.outputs.allowed == 'true'
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Authenticate Docker with Artifact Registry
        if: steps.registry-gate.outputs.allowed == 'true'
        env:
          AR_HOST: ${{ env.AR_HOST }}
        run: |
          gcloud auth configure-docker "$AR_HOST" -q

      - name: Push container images
        if: steps.registry-gate.outputs.allowed == 'true'
        env:
          IMAGES: ${{ steps.build-images.outputs.images }}
        run: |
          set -euo pipefail
          while IFS= read -r IMAGE; do
            [[ -z "$IMAGE" ]] && continue
            echo "\n>>> Pushing $IMAGE"
            docker push "$IMAGE"
          done <<< "$IMAGES"

      - name: Get GKE credentials
        if: steps.registry-gate.outputs.allowed == 'true' && env.GKE_CLUSTER != '' && env.GKE_LOCATION != ''
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_LOCATION }}

      - name: Update Kubernetes deployments with new image tags
        if: steps.registry-gate.outputs.allowed == 'true' && env.GKE_CLUSTER != '' && env.GKE_LOCATION != ''
        env:
          IMAGES: ${{ steps.build-images.outputs.images }}
          K8S_NAMESPACE: ${{ env.K8S_NAMESPACE }}
        run: |
          set -euo pipefail
          while IFS= read -r IMAGE; do
            [[ -z "$IMAGE" ]] && continue
            IMAGE_NAME="${IMAGE##*/}"
            DEPLOYMENT="${IMAGE_NAME%%:*}"
            echo "\n>>> Updating deployment/$DEPLOYMENT in namespace $K8S_NAMESPACE to $IMAGE"
            kubectl set image deployment/"$DEPLOYMENT" "$DEPLOYMENT"="$IMAGE" -n "$K8S_NAMESPACE"
          done <<< "$IMAGES"

      - name: Summarize CI results
        env:
          IMAGES: ${{ steps.build-images.outputs.images }}
          TAG: ${{ steps.meta.outputs.tag }}
        run: |
          {
            echo "## Build summary"
            echo "* Git ref: $GITHUB_REF"
            echo "* Commit: $GITHUB_SHA"
            echo "* Image tag: ${TAG:-n/a}"
            if [[ -n "$IMAGES" ]]; then
              echo "\n### Images"
              while IFS= read -r IMAGE; do
                [[ -z "$IMAGE" ]] && continue
                echo "- $IMAGE"
              done <<< "$IMAGES"
            fi
          } >> "$GITHUB_STEP_SUMMARY"